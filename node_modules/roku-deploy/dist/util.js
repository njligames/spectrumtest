"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.standardizePath = exports.util = exports.Util = void 0;
const fsExtra = require("fs-extra");
const path = require("path");
const fs = require("fs");
class Util {
    /**
     * Determine if `childPath` is contained within the `parentPath`
     * @param parentPath
     * @param childPath
     */
    isParentOfPath(parentPath, childPath) {
        parentPath = exports.util.standardizePath(parentPath);
        childPath = exports.util.standardizePath(childPath);
        const relative = path.relative(parentPath, childPath);
        return relative && !relative.startsWith('..') && !path.isAbsolute(relative);
    }
    /**
     * Determines if the given path is a file
     * @param filePathAbsolute
     */
    async isFile(filePathAbsolute) {
        try {
            //get the full path to the file. This should be the same path for files, and the actual path for any symlinks
            let realPathAbsolute = fs.realpathSync(filePathAbsolute);
            let stat = await fsExtra.lstat(realPathAbsolute);
            return stat.isFile();
        }
        catch (e) {
            // lstatSync throws an error if path doesn't exist
            return false;
        }
    }
    /**
     * Normalize path and replace all directory separators with current OS separators
     * @param thePath
     */
    standardizePath(thePath) {
        if (!thePath) {
            return thePath;
        }
        return path.normalize(thePath.replace(/[\/\\]+/g, path.sep));
    }
    /**
     * Convert all slashes to forward slashes
     */
    toForwardSlashes(thePath) {
        if (typeof thePath === 'string') {
            return thePath.replace(/[\/\\]+/g, '/');
        }
        else {
            return thePath;
        }
    }
    /**
     * Do a case-insensitive string replacement
     * @param haystack
     * @param needle
     * @param replace
     */
    stringReplaceInsensitive(haystack, needle, replace) {
        let idx = haystack.toLowerCase().indexOf(needle.toLowerCase());
        if (idx > -1) {
            return haystack.substr(0, idx) + replace + haystack.substr(idx + needle.length);
        }
        else {
            return haystack;
        }
    }
    /**
     * Keep calling the callback until it does NOT throw an exception, or until the max number of tries has been reached.
     * @param callback
     * @param maxTries
     * @param sleepMilliseconds
     */
    /* istanbul ignore next */ //typescript generates some weird while statement that can't get fully covered for some reason
    async tryRepeatAsync(callback, maxTries = 10, sleepMilliseconds = 50) {
        let tryCount = 0;
        while (true) {
            try {
                return await Promise.resolve(callback());
            }
            catch (e) {
                tryCount++;
                if (tryCount > maxTries) {
                    throw e;
                }
                else {
                    await this.sleep(sleepMilliseconds);
                }
            }
        }
    }
    async sleep(milliseconds) {
        await new Promise((resolve) => {
            setTimeout(resolve, milliseconds);
        });
    }
    /**
     * Determine if a file exists (case insensitive)
     */
    async fileExistsCaseInsensitive(filePath) {
        filePath = this.standardizePath(filePath);
        const lowerFilePath = filePath.toLowerCase();
        const parentDirPath = path.dirname(filePath);
        //file can't exist if its parent dir doesn't exist
        if (await fsExtra.pathExists(parentDirPath) === false) {
            return false;
        }
        //get a list of every file in the parent directory for this file
        const filesInDir = await fsExtra.readdir(parentDirPath);
        //look at each file path until we find the one we're searching for
        for (let dirFile of filesInDir) {
            const dirFilePath = this.standardizePath(`${parentDirPath}/${dirFile}`);
            if (dirFilePath.toLowerCase() === lowerFilePath) {
                return true;
            }
        }
        return false;
    }
}
exports.Util = Util;
exports.util = new Util();
/**
 * A tagged template literal function for standardizing the path.
 */
function standardizePath(stringParts, ...expressions) {
    let result = [];
    for (let i = 0; i < stringParts.length; i++) {
        result.push(stringParts[i], expressions[i]);
    }
    return exports.util.standardizePath(result.join(''));
}
exports.standardizePath = standardizePath;
//# sourceMappingURL=util.js.map